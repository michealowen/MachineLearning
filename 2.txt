void NetComm::Blur(int idx, bool bLeft[8], bool bRight[8], unsigned char* pData[8], DataInfo pDataInfo[8])
{
	unsigned imgW = ((pDataInfo[idx].ImageWidth + 31) / 32) * 4;    //得到每行像素的字节数
	PBYTE pDstLeft, pDstRight = m_pBlurData[idx] + g_nHoleClose[idx] * imgW, pSrc = m_pBlurTemp;
	memset(pDstRight, 0, imgW * g_nBlurWidth);              //将pDstRight的第一个位置开始的imgW * g_nBlurWidth个位置赋值为0
	if (bLeft[idx - 1] || g_nHoleClose[idx - 1])            //若bLeft[idx - 1]或g_nHoleClose[idx - 1]等于1
		pDstLeft = m_pBlurData[idx - 1] + imgW * (pDataInfo[idx - 1].ImageHeight + g_nBlurWidth + g_nHoleClose[idx - 1]);
	else
		pDstLeft = pData[idx - 1] + imgW * (pDataInfo[idx - 1].ImageHeight - g_nBlurWidth);
	memset(pDstLeft, 0, imgW * g_nBlurWidth);               //将pDstLeft的第一个位置开始的imgW * g_nBlurWidth个位置赋值为0
	auto gen = std::bind(std::uniform_int_distribution<unsigned>(), std::mt19937((unsigned)std::chrono::system_clock::now().time_since_epoch().count()));   //重新绑定生成新的对象
	for (int i, k, j = 0; j < g_nBlurWidth; ++j)
	{
		for (i = 0; i < imgW; ++i)
		{
			for (k = 0; k < 8; ++k)
			{
				if ((pSrc[i] >> (7 - k)) & 0x01)       // pSrc[i]右移（7-k）位  ，再与1按位与
				{
					if (gen() < g_pBlur[j])       //若gen() < g_pBlur[j]
  						pDstLeft[i] |= 1 << (7 - k);     //pDstLeft[i]等于    pDstLeft[i]按位或2^(7-k)的值
					else
						pDstRight[i] |= 1 << (7 - k);    //否则pDstRight[i]等于   pDstRight[i]按位或2^(7-k)的值
				}
			}
		}
		pDstLeft += imgW;     //pDstLeft = pDstLeft+imgW
		pDstRight += imgW;    //pDstRight = pDstRight+imgW
		pSrc += imgW;         //pSrc = pSrc+imgW
	}
}
